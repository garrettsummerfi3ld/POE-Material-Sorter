#pragma config(Sensor, in1, lightSensor, sensorReflection)
#pragma config(Sensor, in2, lineFollower, sensorLineFollower)
#pragma config(Sensor, dgtl1, encoder, sensorQuadEncoder)
#pragma config(Motor, port2, flash, tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor, port3, turntableMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port4, rodMotor, tmotorVex393_MC29, openLoop)
#pragma DebuggerWindows("debugStream")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Variables for processing sorts
int currentStorageContainer = 1;
int calledStorageContainer = 0;
int waitTimer;
bool detect = true;
bool callReset = true;

// Variables for referencing to base values of materials
// Steel Vals
int steelLineVal = 220;
int steelLightVal = 2200;
// Clear Vals
int clearLineVal = 40;
int clearLightVal = 2800;
// Wood vals
int woodLineVal = 600;
int woodLightVal = 1800;
// Plastic Vals
int plasticLineVal = 150;
int plasticLightVal = 210;

// Checks for around the goal amount for each material
bool checkAround(int value, int goal) {
	if (value > 1000) {
		if (goal - 500 < value && value < goal + 500) {
			writeDebugStreamLine("[GOAL] True!");
			return true;
		} else {
			writeDebugStreamLine("[GOAL] False!");
			return false;
		}
	} else {
		if (goal - 40 < value && value < goal + 40) {
			writeDebugStreamLine("[GOAL] True!");
			return true;
		} else {
			writeDebugStreamLine("[GOAL] False!");
			return false;
		}
	}
}

// Detects the item in the sorting mechanism
task detectMaterial() {
	writeDebugStreamLine("[DECT] 'detectMaterial' task started!");
	while (detect) {
		if (SensorValue(lightSensor) > 30 || SensorValue(lineFollower) < 2960) {
			writeDebugStreamLine("[DECT] Detecting material...");
			// Clear detection process
			if (checkAround(SensorValue(lightSensor), clearLightVal) && checkAround(SensorValue(lineFollower), clearLineVal)) {
				writeDebugStreamLine("[DECT] Detecting 'clear'...");
				calledStorageContainer = 1;
				wait(1);
			}
			// Plastic detection process
			if (checkAround(SensorValue(lightSensor), plasticLightVal) && checkAround(SensorValue(lineFollower), plasticLineVal)) {
				writeDebugStreamLine("[DECT] Detecting 'plastic'...");
				calledStorageContainer = 2;
				wait(1);
			}
			// Wood detection process
			if (checkAround(SensorValue(lightSensor), woodLightVal) && checkAround(SensorValue(lineFollower), woodLineVal)) {
				writeDebugStreamLine("[DECT] Detecting 'wood'...");
				calledStorageContainer = 3;
				wait(1);
			}
			// Steel detection process
			if (checkAround(SensorValue(lightSensor), steelLightVal) && checkAround(SensorValue(lineFollower), steelLineVal)) {
				writeDebugStreamLine("[DECT] Detecting 'steel'...");
				calledStorageContainer = 4;
				wait(1);
			}	else {
				writeDebugStreamLine("[DECT] [WARN] Nothing is recognized! Are the values calibrated for the room?");
				wait(1);
			}
		}
	}
}

// Moves the platform positive to the desired storage container
task rotatePosititve() {
	// While not detecting...
	while (!detect) {
		// Power motor
		writeDebugStreamLine("[ROTE] [POS] Powering motor to '30'...");
		motor[turntableMotor] = 30;
		// If current storage container is one less than the called storage container...
		if (currentStorageContainer == calledStorageContainer - 1) {
			// Slow motor
			writeDebugStreamLine("[ROTE] [POS] Slowing down motor to '10'...");
			motor[turntableMotor] = 10;
		}
		// If current storage container matches called container...
		if (currentStorageContainer == calledStorageContainer) {
			// Kill motor, push material with rodMotor, reset called storage container and reset detect and call reset flags
			writeDebugStreamLine("[ROTE] [POS] Stopping turntableMotor...");
			motor[turntableMotor] = 0;
			writeDebugStreamLine("[ROTE] [POS] Stopped!");
			writeDebugStreamLine("[ROTE] [POS] Starting rodMotor...");
			motor[rodMotor] = 30;
			wait(1);
			writeDebugStreamLine("[ROTE] [POS] Reversing rodMotor...");
			motor[rodMotor] = -30;
			wait(1);
			writeDebugStreamLine("[ROTE] [POS] Stopping rodMotor...");
			motor[rodMotor] = 0;
			calledStorageContainer = 0;
			detect = true;
			callReset = true;
		}
	}
}

// Moves the platform negative to the desired storage container
task rotateNegative() {
	// While not detecting...
	while (!detect) {
		// Power Motor
		writeDebugStreamLine("[ROTE] [NEG] Powering motor to '30'...");
		motor[turntableMotor] = -30;
		// If if current storage container is one higher than called container...
		if (currentStorageContainer == calledStorageContainer + 1) {
			// Slow motor
			writeDebugStreamLine("[ROTE] [NEG] Slowing down motor to '10'...");
			motor[turntableMotor] = -10;
		}
		// If current storage container matches the called container
		if (currentStorageContainer == calledStorageContainer) {
			// Kill motor, reset called storage container and reset detect and call reset flags
			writeDebugStreamLine("[ROTE] [NEG] Stopping motor...");
			motor[turntableMotor] = 0;
			writeDebugStreamLine("[ROTE] [NEG] Stopped!");
			writeDebugStreamLine("[ROTE] [NEG] Starting rodMotor...");
			motor[rodMotor] = 30;
			wait(1);
			writeDebugStreamLine("[ROTE] [NEG] Reversing rodMotor...");
			motor[rodMotor] = -30;
			wait(1);
			writeDebugStreamLine("[ROTE] [NEG] Stopping rodMotor...");
			motor[rodMotor] = 0;
			calledStorageContainer = 0;
			detect = true;
			callReset = true;
		}
	}
}

// Sets the turntable turn to whatever encoder value is set
task detectStorageContainer() {
	while (true) {
		if (SensorValue(encoder) > -40 && SensorValue(encoder)<= 300) {
			// Clear Storage
			if (SensorValue(encoder) >= -25 && SensorValue(encoder) <= 25) {
				writeDebugStreamLine("[STOR] Detected storage container 1");
				currentStorageContainer = 1;
				wait(1);
			}
			// Plastic Storage
			if (SensorValue(encoder) >= 65 && SensorValue(encoder) <= 115) {
				writeDebugStreamLine("[STOR] Detected storage container 2");
				currentStorageContainer = 2;
				wait(1);
			}
			// Wood Storage
			if (SensorValue(encoder) >= 155 && SensorValue(encoder) <= 205) {
				writeDebugStreamLine("[STOR] Detected storage container 3");
				currentStorageContainer = 3;
				wait(1);
			}
			// Steel Storage
			if (SensorValue(encoder) >= 245 && SensorValue(encoder) <= 295) {
				writeDebugStreamLine("[STOR] Detected storage container 4");
				currentStorageContainer = 4;
				wait(1);
			}
			// Out of bounds negative
			if (SensorValue(encoder) < -15) {
				writeDebugStreamLine("[STOR] [WARN] Turntabe out of bounds in negative!");
				writeDebugStreamLine("[STOR] Resetting position to container 1...");
				currentStorageContainer = 0;
				calledStorageContainer = 1;
				wait(1);
			}
			// Out of bounds posititve
			if (SensorValue(encoder) > 290) {
				writeDebugStreamLine("[STOR] [WARN] Turntable out of bounds in positive!");
				writeDebugStreamLine("[STOR] Resetting position to container 1...");
				currentStorageContainer = 5;
				calledStorageContainer = 1;
				wait(1);
			}
		}
	}
}

// Logic for sensor readings and how to process
task checkDetect() {
	// Clearing timer
	writeDebugStreamLine("[LSTN] clearing timer 'T1'...");
	clearTimer(T1);
	writeDebugStreamLine("[LSTN] Timer cleared!");
	while (detect) {
		// Only activate after init
		if (calledStorageContainer > 0) {
			// Set detect variable to false
			// This prevents any other input from the sensors
			writeDebugStreamLine("[LSTN] Attemping to stop detecting to inputs...");
			detect = false;
			writeDebugStreamLine("[LSTN] Stopped detecting!");
			// Conditionals for what storage container is there
			if (currentStorageContainer < calledStorageContainer) {
				startTask(rotatePosititve);
				} else if (currentStorageContainer > calledStorageContainer) {
				startTask(rotateNegative);
				} else {
				// waitTimer var is assigned to T1
				waitTimer = T1;
				// Starts time for Idle process
				if (waitTimer > 20000) {
					writeDebugStreamLine("[IDLE] Starting idle process...");
					calledStorageContainer = 1;
				}
			}
		}
	}
}

// Main task
task main() {
	clearDebugStream();
	// Storage container detection
	startTask(detectStorageContainer);
	while (true) {
		// Flash turning on
		turnFlashlightOn(flash, -127);
		// Call reset
		if (callReset) {
			// Set var to false and run two tasks
			callReset = false;
			startTask(checkDetect);
			startTask(detectMaterial);
		}
	}
}
